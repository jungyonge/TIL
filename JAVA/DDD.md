# DDD 레이어드 아키텍처

Focus on Domain
여기서 도메인은 실세계에서 발생할 수 있는 사건 그 자체라고 생각하면 쉽습니다. 간편결제 서비스를 예로 들어볼까요?

서비스에서 사용되는 포인트를 충전하기 위한 충전 도메인(Charge Domain)이 있을 수 있고, 이렇게 충전된 포인트로 결제를 수행하는 결제 도메인(Payment Domain)이 있을 수 있습니다.  
그리고 각 도메인에는 이를 구현하기 위한 여러 객체가 필요하게됩니다.
~~~
충전 도메인: 포인트, 고객, 충전 수단, ...
결제 도메인: 포인트, 고객, 결제 상품, ....
~~~
잘 보면 서로 다른 도메인이지만 같은 객체(포인트, 고객)가 존재하는데요. 이는 같은 객체가 여러 개 존재할 수 있다는 도메인 주도 설계의 특징 중 하나입니다.   
같은 객체이지만, 그 객체가 속한 도메인의 문맥(Context)에 따라 각 객체의 역할과 책임이 크게 바뀌게 되는 것이지요.  

그런데 현재 나는 완벽히 도메인별로 중복된 객체를 또 생성하지 않고 중복해서 사용하고 있다.
혹여나 분리할때는 그대로 복사 하면 되니 괜찮을듯 하다.

그래서 이러한 객체들은 외부로 노출시키지 않고, 내부에서만 알 수 있게 합니다. 다른 도메인에서는 알 필요가 없으니까요.  

즉, 이는 서로 다른 도메인 영역에 영향을 끼치기 위해서는 API를 이용해야 한다는 말이기도 한데요.   
이를 통해 각각의 도메인은 서로 철저히 분리되고, 높은 응집력과 낮은 결합도로 변경과 확장에 용이한 구조를 얻게됩니다.

그리고 DDD를 실제로 구현할 때에는 크게 3가지 Layer로 구분하는 것이 핵심입니다.

- Application Layer: 주로 도메인과 Repository를 바탕으로 실제 서비스(API)를 제공하는 계층
- Domain Model Layer: Entity를 활용해 도메인 로직(비즈니스 로직)이 수행되는 계층
- Infrastructure Layer: 외부와 통신(RDBMS, Redis, HttpClient, ...)을 담당하는 계층

결국 각 도메인을 분리하고, 그 도메인을 위와 같은 Layer로 철저히 분리해서 만드는 것이 DDD라 볼 수 있습니다.

### Layered Architecture 규칙
- 상위 계층이 하위 계층을 호출하는 단방향성을 유지한다.
- 상위 계층은 하위의 여러 계층을 모두 알 필요없이 바로 밑의 근접 계층만 활용한다.
- 상위 계층이 하위 계층에 영향을 받지 않게 구성해야 한다. (중간 계층을 기준으로)
- 하위 계층은 자신을 사용하는 상위 계층을 알지 못하게 구성해야 한다.
- 계층 간의 호출은 인터페이스를 이용한다. (구현 클래스에 직접 의존하지 않음으로써 약한 결합을 유지해야 한다.)
  - 이러면 서비스 레이어도 죄다 인터페이스로 해야하나.. 흠
  - 무작정 인터페이스 구성은 별로 안 좋은 것 같다는 개인적인 생각..