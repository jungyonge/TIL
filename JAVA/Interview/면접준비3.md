- StackOverFlowError란?
    - Java의 런타임 오류이다. JVM에 의해 호출 스택 메모리의 양이 초과 되면 throw 된다.
    - StackOverFlowError 과도한 무한재귀또는 무한 재귀 떄문에 호출 스택이 초과 될때 발생하는 일반적인 경
    - 무한 재귀호출을 하는 코딩을 하겠다
        - 무한 재귀호출은 스택 공간이 소모되는 결과를 초래함

- try - catch - finally 구문은 자바 몇버젼부터 사용??
    - 1.7이전 부터 사용했다.
    - finally 블록은 완료된 모든 상황에 실행될 코드
    - 그래서 close등 리로스 관리, 다른종류의 적합
    - finally 블록 내의 코드는 항상 실행된다.
        - jvm이 종료되몀 finally 블록이  실행되지 않을 수 있음
        - 스레드가 인터럽트 되거나 죽는경우에도 마찬가지
    - finally에 리소스를 정리하려고 불필요한 코드가 들어감 
        - 그래서 1.7이상부터 try-with-resource 구문이 나옴
    - 자원을 생성하고 사용하고 해제하는 코드는 항상 구조가 중복되는 코드를 작성해야 했음
    - finally 블록의 자원 해제 코드는 정말 하는거 없이 여러줄을 차지함
    - 코딩할때 귀찮아짐.. 
    - Java 7이상부터 try-with-resource 라는 특징 추가
    - try에 자원객체를 전달하며 finally 블록으로 종료처리 하지 않아도 try 코드 블록이 끝나면 자동으로 자원을 종료해주는 기능

- CSRF 이란? 
    - 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격입니다.
    - 조건
        - 위조 요청을 전송하는 서비스(페이스북)에 희생자가 로그인 상태
        - 희생자가 해커가 만든 피싱 사이트에 접속
    - 방지
        - Referrer 검증
            - Back-end 단에서 request의 referrer를 확인하여 domain (ex. *.facebook.com) 이 일치하는 지 검증하는 방법입니다.  
              일반적으로 referrer 검증만으로 대부분의 CSRF 공격을 방어할 수 있습니다.
        - Security Token 사용 (A.K.A CSRF Token)
            - 사용자의 세션에 임의의 난수 값을 저장하고 사용자의 요청 마다 해당 난수 값을 포함 시켜 전송시킵니다.   
                이후 Back-end 단에서 요청을 받을 때마다 세션에 저장된 토큰 값과 요청 파라미터에 전달되는 토큰 값이 일치하는 지 검증하는 방법입니다

- HashMap, LinkedHashMap, TreeMap 차이점이 뭔가?
    - HashMap : 내부 hash값에 따라서 키순서가 정해지므로 특정 규칙없이 출력됨
    - TreeMap: 내부적으로 RedBlack Tree 로 저장됨, 키 값에 대한 Compartor 구현으로 정렬 순서를 바꿀수 있음
        - 트리에 저장되므로 키값은 일정 기준으로 정렬된 상태로 출력됨
    - LinkedHashMap : 링크드 리스트로 저장됨, 키값은 입력 순서대로 출력이 되어서 나옴
    - 특별한 이유가 없다면 검색 성능이 제일좋은 O(1) HashMap을 사용
    - 키값이 일정한 수준대로 iterate 하려고 한다면 TreeMap 을 사용
        - 하지만 랜덤 접근에 대해서는 O(logn)성능을 지니므로 많은 데이터를 넣을 경우 좋지 않은 성능이 나올수 있음
    - 입력순서가 의미있다면 LinkedHashMap을 사용하자
        - 랜덤 접근에대해 O(n) 성능을 지니므로 많은 데이터를 입력할 경우 사용하지 않는 것이 좋음
