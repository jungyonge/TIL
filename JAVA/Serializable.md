### Serializable

직렬화(serialize)란 자바 언어에서 사용되는 Object 또는 Data를   
다른 컴퓨터의 자바 시스템에서도 사용 할수 있도록 바이트 스트림(stream of bytes) 형태로   
연속전인(serial) 데이터로 변환하는 포맷 변환 기술을 일컫는다.  
그 반대 개념인 역직렬화는(Deserialize)는 바이트로 변환된 데이터를 원래대로 자바 시스템의 Object 또는 Data로 변환하는 기술이다.

이를 시스템적으로 살펴보면, JVM의 힙(heap) 혹은 스택(stack) 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해   
바이트 형태로 변환하여 데이터베이스나 파일과 같은 외부 저장소에 저장해두고,   
다른 컴퓨터에서 이 파일을 가져와 역질렬화를 통해 자바 객체로 변환해서 JVM 메모리에 적재하는 것으로 보면 된다.

Serializable 자체는 마커 인터페이스 임으로 상속하지 않아도 직렬화, 역직렬화는 가능하다.
만약 변수에 transient가 있으면 직렬화를 진행하지 않는다 .

~~~
public class MyClass {
    private int myField;
    private transient String myTransientField;
    // 생성자, 메서드 등 클래스의 구현 내용
}
~~~


### SerialVersionUID
직렬화와 역직렬화를 얘기할 때 빼놓을 수 없는 것이 SerialVersionUID(이하 SUID)다.   
직렬화를 할 때 SUID 선언이 없다면 내부에서 자동으로 유니크한 번호를 생성하여 관리하게 된다.   
SUID는 직렬화와 역직렬화 과정에서 값이 서로 맞는지 확인한 후에 처리를 하기 때문에 이 값이 맞지 않다면 InvalidClassException 예외가 발생한다.  
자바의 직렬화 스펙 정의를 살펴보면 SUID 값은 필수가 아니며 선언되어 있지 않으면 클래스의 기본 해시값을 사용한다.
따라서 직접 SUID를 명시하지 않더라도 내부에서 자동으로 값이 추가되며 이 값들은 클래스의 이름,   
생성자 등과 같이 클래스의 구조를 이용해서 생성한다.   
앞선 예제에서도 직렬화 가능한 클래스(Article)를 선언할 때 SUID 값을 생략했지만 내부적으로 정보가 생성되어 있음을 유추할 수 있다.

~~~
A라는 서버에서 B라는 서버로 SerialDTO라는 클래스의 객체를 전송한다고 가정하겠습니다
. 전송하는 A 서버에 SerialDTO라는 클래스가 있어야 하고, 전송받는 B 서버에는 SerialDTO라는 클래스가 있어야만 합니다.
그래야만 그 클래스의 객체임을 알고 데이터를 받을 수 있습니다.

그런데 만약 A 서버가 갖고 있는 SerialDTO에는 변수가 3개 있고,
B 서버의 SerialDTO에는 변수가 4개 있는 상황이 발생하면 어떻게 될까요?

이러면 자바에서는 제대로 처리를 못하게 됩니다. 
따라서 각 서버가 쉽게 해당 객체가 같은지 다른지를 확인할 수 있도록 하기 위해서는 serialVersionUID로 관리를 해주어야만 합니다.

즉 클래스 이름이 같더라도 이 ID가 다르면 다른 클래스라고 인식합니다. 게다가, 같은 UID라고 할지라도, 
변수의 개수나 타입 등이 다르면 이 경우도 다른 클래스로 인식합니다.
~~~